
/**
 * @module ui
 * Bind Angular.js modules
 */
angular.module('ui.filters', []);
angular.module('ui.directives', []);
angular.module('ui', [
  'ui.filters', 
  'ui.directives'
]).value('ui.config', {});// Generated by CoffeeScript 1.3.3

/*
 Gives the ability to style currency based on its sign.
*/
  angular.module('ui.directives').directive('uiCurrency', function(currencyFilter) {
    return {
      restrict: 'EAC',
      require: '?ngModel',
      link: function($scope, element, attrs, controller) {
        var controllerOptions, options, renderview, value;
        controllerOptions = $scope[attrs.options] || $scope.uiCurrencyOptions | {};
        options = {
          pos: attrs.pos || controllerOptions.pos || 'ui-currency-pos',
          neg: attrs.neg || controllerOptions.neg || 'ui-currency-neg',
          zero: attrs.zero || controllerOptions.zero || 'ui-currency-zero',
          symbol: attrs.symbol || controllerOptions.symbol || void 0
        };
        renderview = function(viewvalue) {
          var num;
          num = viewvalue * 1;
          if (num > 0) {
            element.addClass(options.pos);
          } else {
            element.removeClass(options.pos);
          }
          if (num < 0) {
            element.addClass(options.neg);
          } else {
            element.removeClass(options.neg);
          }
          if (num === 0) {
            element.addClass(options.zero);
          } else {
            element.removeClass(options.zero);
          }
          if (viewvalue === '') {
            element.text('');
          } else {
            element.text(currencyFilter(num, options.symbol));
          }
          return true;
        };
        value = '';
        if (controller != null) {
          controller.$render = function() {
            value = controller.$viewValue;
            element.val(value);
            renderview(value);
          };
        } else {
          if (attrs.num != null) {
            value = $scope[attrs.num];
          }
          renderview(value);
        }
      }
    };
  });

/*
 General-purpose jQuery wrapper. Simply pass the plugin name as the expression.
 
 @TODO Devise a way to pass app-wide defined configuration options. Consider global var. 
 @param [ui-jq] {string} The $elm.[pluginName]() to call.
 @param [ui-options] {mixed} Expression to be evaluated and passed as options to the function
*/

(function() {

  angular.module('ui.directives').directive('uiDate', [
    function() {
      return {
        require: '?ngModel',
        link: function($scope, element, attrs, controller) {
          var originalRender, updateModel, usersOnSelectHandler;
          if ($scope.uiDate == null) $scope.uiDate = {};
          if (controller != null) {
            updateModel = function(value, picker) {
              return $scope.$apply(function() {
                return controller.$setViewValue(element.datepicker("getDate"));
              });
            };
            if ($scope.uiDate.onSelect != null) {
              usersOnSelectHandler = $scope.uiDate.onSelect;
              $scope.uiDate.onSelect = function(value, picker) {
                updateModel(value);
                return usersOnSelectHandler(value, picker);
              };
            } else {
              $scope.uiDate.onSelect = updateModel;
            }
            originalRender = controller.$render;
            controller.$render = function() {
              originalRender();
              return element.datepicker("setDate", controller.$viewValue);
            };
          }
          return element.datepicker($scope.uiDate);
        }
      };
    }
  ]);

}).call(this);
/**
 * General-purpose Event binding. Bind any event not natively supported by Angular
 * Pass an object with keynames for events to ui-event
 * 
 * @example <input ui-event="{ focus : 'counter++', blur : 'someCallback()' }">
 * 
 * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks
 */
angular.module('ui.directives').directive('uiEvent', [function() {
	return function(scope, elm, attrs) {
		var events = scope.$eval(attrs.uiEvent);
		angular.forEach(events, function(event, key){
			elm.bind(key, function() {
				scope.$apply(event);
			});
		});
	};
}]);

/**
 * General-purpose jQuery wrapper. Simply pass the plugin name as the expression.
 * 
 * It is possible to specify a default set of parameters for each jQuery plugin.
 * Under the jq key, namespace each plugin by that which will be passed to ui-jq.
 * Unfortunately, at this time you can only pre-define the first parameter.
 * @example { jq : { datepicker : { showOn:'click' } } }
 * 
 * @param ui-jq {string} The $elm.[pluginName]() to call.
 * @param [ui-options] {mixed} Expression to be evaluated and passed as options to the function
 * 		Multiple parameters can be separated by commas
 * 
 * @example <input ui-jq="datepicker" ui-options="{showOn:'click'},secondParameter,thirdParameter">
 */
angular.module('ui.directives').directive('uiJq', ['ui.config', function(uiConfig) {
	var options = {};
	return {
		link: {
			post: function(scope, elm, attrs) {
				var evalOptions;
				if (uiConfig['jq'] && uiConfig['jq'][attrs.uiJq]) {
					if (angular.isObject(options) && angular.isObject(uiConfig['jq'][attrs.uiJq])) {
						angular.extend(options, uiConfig['jq'][attrs.uiJq]);
					} else {
						options = uiConfig['jq'][attrs.uiJq];
					}
				}
				if (attrs.uiOptions) {
					evalOptions = scope.$eval('['+attrs.uiOptions+']');
					if (angular.isObject(options) && angular.isObject(evalOptions[0])) {
						angular.extend(options, evalOptions[0]);
					} else {
						options = evalOptions[0];
					}
				}
				elm[attrs.uiJq](options);
			}
		}
	};
}]);

/**
 * Bind an event to a particular keypress
 * @param hash {object} keyCode The number keycode to watch (ex: 13 is the return key). The callback function to fire upon keypress. Takes an 'event' param
 * @example <input ui-keypress="{ 13 : someCallback }">
 **/
angular.module('ui.directives').directive('uiKeypress', [function(){
	return {
		link: function(scope, elm, attrs) {
			var params = scope.$eval(attrs.uiKeypress);
			elm.bind('keypress', function(event){
				if (params[event.keyCode]){
					scope.$apply(function(){
						params[event.keyCode](event);
					});
				}
			});
		}
	};
}]);
/*
 Attaches jquery-ui input mask onto input element
*/

(function() {

  angular.module('ui.directives').directive('uiMask', [
    function() {
      return {
        require: 'ngModel',
        scope: {
          uiMask: '='
        },
        link: function($scope, element, attrs, controller) {
          controller.$render = function() {
            var value;
            value = controller.$viewValue || '';
            element.val(value);
            return element.mask($scope.uiMask);
          };
          controller.$parsers.push(function(value) {
            var isValid;
            isValid = element.data('mask-isvalid');
            controller.$setValidity('mask', isValid);
            return element.mask();
          });
          return element.bind('keyup', function() {
            return $scope.$apply(function() {
              return controller.$setViewValue(element.mask());
            });
          });
        }
      };
    }
  ]);

}).call(this);

/**
 * Actually removes html from the DOM instead of hiding it for assistance with 
 * CSS3 selectors such as :first-child, :last-child, etc
 * 
 * NOTE: This solution may not behave perfectly when used with or around other directives that also
 *   manipulate the dom.
 * 
 * @todo Add a more resilient solution to injecting removed elements back into the DOM (instead of relying on nextElm)
 * @param remove {boolean} condition to check if the element should be removed form the DOM
 */
angular.module('ui.directives').directive('uiRemove', [function() {
	return {
		link: function(scope, elm, attrs) {
			var parent = elm.parent();
			var expression = attrs.uiRemove;
			elm.data('ui-remove-index', elm.index());
			scope.$watch(expression, function(newValue, oldvalue) {
				var index, children, child;
				if (newValue) {
					elm.detach(); 
				} else if (!$.contains(parent, elm)) {
					index = elm.data('ui-remove-index');
					children = elm.parent().children();
					if (children.length > 0) {
						for (var i = 0; i < children.length; i++) {
							child = children[i];
							if (index > child.index() && i === children.length-1) {
								child.after(elm);
							} else {
								child.before(elm);
							}
						}
					} else {
						parent.append(elm);
					}
				}
			});
		}
	};
}]);
/**
 * Add a clear button to form inputs to reset their value
 */
angular.module('ui.directives').directive('uiReset', [function() {
	return function(scope, elm, attrs) {
		elm.wrap('<span class="ui-resetwrap" />').after('<a class="ui-reset" />').next().click(function(e){
			e.preventDefault();
			elm.val(null).trigger('change');
			// scope[attrs.ngModel] = null;
			// scope[attrs.ngModelInstant] = null;
			// scope.$apply();
		});
	};
}]);/**
 * Adds a 'ui-scrollfix' class to the element when the page scrolls past it's position.
 * @param [offset] {int} optional Y-offset to override the detected offset.
 *   Takes 300 (absolute) or -300 or +300 (relative to detected)
 */
angular.module('ui.directives').directive('uiScrollfix', [function() {
	return {
		link: {
			post: function(scope, elm, attrs) {
				var top = elm.offset().top;
				if (!attrs.uiScrollfix) {
					attrs.uiScrollfix = top;
				} else {
					if (attrs.uiScrollfix.indexOf('-') === 0) {
						attrs.uiScrollfix = top - attrs.uiScrollfix.substr(1);
					} else if (attrs.uiScrollfix.indexOf('+') === 0) {
						attrs.uiScrollfix = top + parseInt(attrs.uiScrollfix.substr(1));
					}
				}
				$(window).bind('scroll.ui-scrollfix', function(){
					if (!elm.hasClass('ui-scrollfix') && window.pageYOffset > attrs.uiScrollfix) {
						elm.addClass('ui-scrollfix');
					} else if (elm.hasClass('ui-scrollfix') && window.pageYOffset < attrs.uiScrollfix) {
						elm.removeClass('ui-scrollfix');
					}
				});
			}
		}
	};
}]);

/**
 * Enhanced Select2 Dropmenus
 *
 * @concerns When the plugin loads, it injects an extra DIV into the DOM below itself. This disrupts the
 *   compiler, breaking everything below. Because of this, it must be initialized asynchronously (late).
 *   Since the ng:model and ng:options/ng:repeat can be populated by AJAX, they must be monitored in order
 *   to refresh the plugin so that it reflects the selected value
 * @AJAX Multiselect - For these, you must use an <input>. The values will NOT be in the form of an Array,
 *   but a comma-separated list. You must adjust the value as needed before using accordingly
 * @params [options] {object} The configuration options passed to $().select2(). Refer to the documentation
 *   - [watch] {string} an expression to monitor for changes. For use with ng:repeat populated via ajax
 *   - [ajax.initial] {function(url, values, multiple)} a callback function that returns the query string
 *   		to retrieve initial information about preselected/default values
 */
angular.module('ui.directives').directive('uiSelect2', ['ui.config', '$http', function(uiConfig, $http){
	var options = {};
	if (uiConfig.select2) {
		angular.extend(options, uiConfig.select2);
	}
	return {
		require: '?ngModel',
		link: function(scope, elm, attrs, controller) {
			var init = true, // Only query the selected value's data when the plugin loads
				opts, // instance-specific options
				prevVal = '',
				loaded = false;

			opts = angular.extend({}, options, scope.$eval(attrs.uiSelect2));
			if (!elm.is('select') && attrs.multiple !== undefined) {
				opts.multiple = true;
				// Set the view and model value and update the angular template manually for the ajax/multiple select2.
			     elm.bind("change", function(){
			         controller.$setViewValue(elm.val());
			         scope.$apply();
			     });
			}

			function initialize(newVal) {
				setTimeout(function(){
					if (newVal !== undefined) {
						if (opts.ajax) {
							if (newVal && !$.isEmptyObject(newVal)) {
								if (init && opts.initial) {
									var url = opts.initial(opts.ajax.url, newVal, opts.multiple);
								    $http({ method: 'GET', url: url }).success(function(data, status, headers, config){
										data = opts.ajax.results(data);
										elm.select2('val', data.results || '');
									});
									init = false;
								}
							} else {
							    elm.select2('val', '');
							}
						} else {
							elm.select2('val', newVal);
						}
					}
				},0);
			}

			// Initialize the plugin late so that the injected DOM does not disrupt the template compiler
			// ToDo: $timeout service
			setTimeout(function(){
				elm.select2(opts);
				loaded = true;
				// If a watch was fired before initialized, set the init value
				initialize(prevVal);
			},0);

			// Watch the model for programmatic changes
			scope.$watch(attrs.ngModel, function(newVal, oldVal, scope) {
				if (newVal === prevVal) {
					return;
				}
				if (loaded) {
					initialize(newVal);
					if (!newVal) {
					    // Push the model change to the view(only the null value in this case)
					    elm.select2('val', '');
					}
				}
				prevVal = newVal;
			});
			// If you want you can watch the options dataset for changes
			if (angular.isString(opts.watch)) {
				scope.$watch(opts.watch, function(newVal, oldVal, scope){
					if (loaded && prevVal) {
						setTimeout(function(){
							elm.select2('val', prevVal);
						},0);
					}
				});
			}
		}
	};
}]);
/**
 * NOTE: Only adds classes, you must add the class definition yourself
 */

/**
 * uiShow Directive
 *
 * Adds a 'ui-show' class to the element instead of display:block
 * Created to allow tighter control  of CSS without bulkier directives
 *
 * @param expression {boolean} evaluated expression to determine if the class should be added
 */
angular.module('ui.directives').directive('uiShow', [function() {
	return function(scope, elm, attrs) {
		scope.$watch(attrs.uiShow, function(newVal, oldVal){
			if (newVal) {
				elm.addClass('ui-show');
			} else {
				elm.removeClass('ui-show');
			}	
		});
	};
}])

/**
 * uiHide Directive
 *
 * Adds a 'ui-hide' class to the element instead of display:block
 * Created to allow tighter control  of CSS without bulkier directives
 *
 * @param expression {boolean} evaluated expression to determine if the class should be added
 */
.directive('uiHide', [function() {
	return function(scope, elm, attrs) {
		scope.$watch(attrs.uiHide, function(newVal, oldVal){
			if (newVal) {
				elm.addClass('ui-hide');
			} else {
				elm.removeClass('ui-hide');
			}
		});
	};
}])

/**
 * uiToggle Directive
 *
 * Adds a class 'ui-show' if true, and a 'ui-hide' if false to the element instead of display:block/display:none
 * Created to allow tighter control  of CSS without bulkier directives. This also allows you to override the
 * default visibility of the element using either class.
 *
 * @param expression {boolean} evaluated expression to determine if the class should be added
 */
.directive('uiToggle', [function() {
	return function(scope, elm, attrs) {
		scope.$watch(attrs.uiToggle, function(newVal, oldVal){
			if (newVal) {
				elm.removeClass('ui-hide').addClass('ui-show');
			} else {
				elm.removeClass('ui-show').addClass('ui-hide');
			}
		});
	};
}]);  angular.module('ui.directives').directive('uiTemplate', [
    function() {
      return {
        restrict: 'EAC', // supports using directive as element, attribute and class
        require: '?ngModel', // supports hanging optional ng-model as attribute for two-way data binding   
        link: function($scope, element, attrs, controller) {
          var controllerOptions, options, value = '';
          
          // NOTE: angular.extends does not behave the way I expect it to. Need to research more. 
          
          /* pull in your controller options
             1. check ui-options
             2. check uiTemplateOptions in scope
             3. set to empty hash
          */
          controllerOptions = $scope[attrs.options] || $scope.uiTemplateOptions || {};
          
          /* setup options by looking at each attribute on element, and 
           * if not there, check the controller options
           * or set to some default value
          */
          options = {
            someattr: attrs.someattr || controllerOptions.someattr || 'someDefaultValue'
          };
          
          // below is simplistic, but could do stuff, see ui-currency
          var renderView = function(value) {
            element.text(value);
          }
          
          // if you find a controller use this to do your rendering
          // NOTE: you must call controller.$render 
          if (controller != null) {
            controller.$render = function() {
              // ensure element has the controller's view value
              // TODO: find out from Pete what cases this is needed (see uiMask)
              var modelValue = controller.$viewValue;
              element.val(modelValue != null ? modelValue: ''); 
              renderView(controller.$viewValue);
            };
          } else {
        	// grab value from model
        	renderView($scope[attrs.somemodel] || '');
          } 
        }
      };
    }
  ]);

/**
 * Binds a TinyMCE widget to <textarea> elements.
 */
angular.module('ui.directives').directive('uiTinymce', ['ui.config', function(uiConfig){
	uiConfig.tinymce = uiConfig.tinymce || {};
	return function(scope, elm, attrs) {
		var expression,
		  options = {
			// Update model on button click
			onchange_callback: function(inst) {
				if (inst.isDirty()) {
					inst.save();
					elm.trigger('change');
				}
			},
			// Update model on keypress
			handle_event_callback: function(e) {
				if (this.isDirty()) {
					this.save();
					elm.trigger('change');
				}
				return true; // Continue handling
			},
			// Update model when calling setContent (such as from the source editor popup)
			setup : function(ed) {
				ed.onSetContent.add(function(ed, o) {
					if (ed.isDirty()) {
						elm.trigger('change');
					}
				});
			}
		};
		if (attrs.uiTinymce) {
			expression = scope.$eval(attrs.uiTinymce);
		} else {
			expression = {};
		}
		angular.extend(options, uiConfig.tinymce, expression);
		setTimeout(function(){
			elm.tinymce(options);
		}, 0);
	};
}]);
/**
 * Adds a 'fixed' class to the element when the page scrolls past it's position.
 * @param expression {boolean} condition to check if it should be a link or not
 */
angular.module('ui.filters').filter('highlight', function() {
	return function(text, filter) {
		if (filter === undefined) {
			return text;
		} else {
			return text.replace(new RegExp(filter, 'gi'), '<span class="ui-match">$&</span>');
		}
	};
});
/**
 * Returns the length property of the filtered object
 */
angular.module('ui.filters').filter('length', function() {
	return function(value) {
		return value.length;
	};
});
/**
 * Filters out all duplicate items from an array by checking the specified key
 * @param [key] {string} the name of the attribute of each object to compare for uniqueness
	if the key is empty, the entire object will be compared
	if the key === false then no filtering will be performed
 * @return {array}
 */
angular.module('ui.filters').filter('unique', function() {
	return function(items, key) {
		if (key && angular.isArray(items)) {
			var hashCheck = {},
				newItems = [];
			angular.forEach(items, function(item, key){
				var value;
				if (angular.isString(key)) {
					value = item[key];
				} else {
					value = item;
				}
				if (hashCheck[value] === undefined) {
					hashCheck[value] = true;
					newItems.push(item);
				}
			});
			items = newItems;
		}
		return items;
	};
});